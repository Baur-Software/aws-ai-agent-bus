
name: Full Integration Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-all:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: ['mcp-rust', 'dashboard-server', 'dashboard-ui']
        version: ['20'] # Node version for JS components, ignored for Rust

    steps:
    - uses: actions/checkout@v4

    - name: Setup toolchain
      run: |
        if [ "${{ matrix.component }}" = "mcp-rust" ]; then
          # Install Rust
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source $HOME/.cargo/env
        else
          # Install Node.js for JS components
          curl -fsSL https://deb.nodesource.com/setup_${{ matrix.version }}.x | sudo -E bash -
          sudo apt-get install -y nodejs
        fi

    - name: Install dependencies (${{ matrix.component }})
      run: |
        cd ${{ matrix.component }}
        if [ "${{ matrix.component }}" = "mcp-rust" ]; then
          source $HOME/.cargo/env
          cargo build
        elif [ "${{ matrix.component }}" = "dashboard-server" ]; then
          # Use Bun for dashboard-server
          curl -fsSL https://bun.sh/install | bash
          export PATH="$HOME/.bun/bin:$PATH"
          bun install --frozen-lockfile
        else
          npm ci
        fi

    - name: Run tests (${{ matrix.component }})
      run: |
        cd ${{ matrix.component }}
        if [ "${{ matrix.component }}" = "mcp-rust" ]; then
          source $HOME/.cargo/env
          cargo test
        elif [ "${{ matrix.component }}" = "dashboard-server" ]; then
          export PATH="$HOME/.bun/bin:$PATH"
          bun test --timeout 30000
        elif [ "${{ matrix.component }}" = "dashboard-ui" ]; then
          npm run test:ci
        fi
      env:
        NODE_ENV: test
        ENABLE_DEV_AUTH: true

  terraform-all:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.5

    - name: Terraform Format Check
      run: terraform fmt -check -recursive infra/

    - name: Validate All Terraform
      run: |
        # Validate modules
        for dir in infra/modules/*/; do
          echo "Validating module: $dir"
          cd "$dir"
          terraform init -backend=false
          terraform validate
          cd "$GITHUB_WORKSPACE"
        done

        # Validate workspaces
        for dir in infra/workspaces/*/; do
          if [ -f "$dir/main.tf" ]; then
            echo "Validating workspace: $dir"
            cd "$dir"
            terraform init -backend=false
            terraform validate
            cd "$GITHUB_WORKSPACE"
          fi
        done

        # Validate nested workspaces
        for dir in infra/workspaces/*/*/; do
          if [ -f "$dir/main.tf" ]; then
            echo "Validating nested workspace: $dir"
            cd "$dir"
            terraform init -backend=false
            terraform validate
            cd "$GITHUB_WORKSPACE"
          fi
        done

  build-all:
    runs-on: ubuntu-latest
    needs: test-all
    steps:
    - uses: actions/checkout@v4

    - name: Use Node.js 20
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Setup Bun
      run: |
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"
        bun --version

    - name: Build MCP Server
      run: |
        cd mcp-server
        npm ci
        echo "✅ MCP Server dependencies installed"

    - name: Build Dashboard Server
      run: |
        cd dashboard-server
        export PATH="$HOME/.bun/bin:$PATH"
        bun install --frozen-lockfile
        bun run build
        echo "✅ Dashboard Server built"

    - name: Build Dashboard UI
      run: |
        cd dashboard-ui
        npm ci
        npm run build
        echo "✅ Dashboard UI built"

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [test-all, terraform-all]
    # Only run on GitHub Actions (not act)
    if: ${{ !contains(github.actor, 'nektos/act') }}
    outputs:
      workspace-id: ${{ steps.deploy.outputs.workspace-id }}
      dashboard-url: ${{ steps.deploy.outputs.dashboard-url }}
    steps:
    - uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.5

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Deploy test infrastructure
      id: deploy
      run: |
        # Use unique workspace for this CI run
        WORKSPACE_ID="ci-test-${{ github.run_id }}-${{ github.run_attempt }}"
        echo "workspace-id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

        cd infra/workspaces/small

        # Initialize and deploy
        terraform init
        terraform workspace select $WORKSPACE_ID || terraform workspace new $WORKSPACE_ID
        terraform plan -var="env=ci-test" -out=tfplan
        terraform apply tfplan

        # Get outputs
        DASHBOARD_URL=$(terraform output -raw dashboard_url || echo "")
        echo "dashboard-url=$DASHBOARD_URL" >> $GITHUB_OUTPUT

        echo "✅ Infrastructure deployed with workspace: $WORKSPACE_ID"

  deploy-artifacts:
    runs-on: ubuntu-latest
    needs: [build-all, deploy-infrastructure]
    # Only run on GitHub Actions (not act)
    if: ${{ !contains(github.actor, 'nektos/act') }}
    steps:
    - uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Use Node.js 20
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Setup Bun
      run: |
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"

    - name: Build and deploy Dashboard Server
      run: |
        WORKSPACE_ID="${{ needs.deploy-infrastructure.outputs.workspace-id }}"
        AWS_REGION="us-west-2"
        ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
        ECR_REPOSITORY="agent-mesh-dashboard-server"
        IMAGE_TAG="ci-${{ github.run_id }}-${{ github.run_attempt }}"

        # Build Docker image
        cd dashboard-server
        docker build -t $ECR_REPOSITORY:$IMAGE_TAG .

        # Login to ECR
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

        # Create repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION

        # Tag and push image
        docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker tag $ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

        # Update ECS service with new image
        CLUSTER_NAME="agent-mesh-${WORKSPACE_ID}-cluster"
        SERVICE_NAME="agent-mesh-${WORKSPACE_ID}-dashboard"

        # Update task definition with new image
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --force-new-deployment \
          --region $AWS_REGION

        echo "✅ Dashboard Server deployed to ECS"

    - name: Build and deploy Dashboard UI
      run: |
        cd dashboard-ui
        npm ci
        npm run build

        # Deploy to S3/CloudFront
        aws s3 sync dist/ s3://agent-mesh-ci-test-${{ needs.deploy-infrastructure.outputs.workspace-id }}-ui/ --delete

        # Invalidate CloudFront cache
        DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Comment=='agent-mesh-ci-test-${{ needs.deploy-infrastructure.outputs.workspace-id }}'].Id" --output text)
        if [ ! -z "$DISTRIBUTION_ID" ]; then
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
        fi

        echo "✅ Dashboard UI deployed to S3"

  integration-test:
    runs-on: ubuntu-latest
    needs: [deploy-artifacts]
    # Run locally with act (container testing) or on GitHub Actions (real AWS)
    steps:
    - uses: actions/checkout@v4

    - name: Integration test - Local (act)
      if: ${{ contains(github.actor, 'nektos/act') }}
      run: |
        echo "Running local integration tests with containers..."

        # Use docker-compose or similar for localstack testing
        # This keeps the existing container-based testing for local development

        # Start MCP Server in HTTP mode for testing
        cd mcp-server
        timeout 30s npm run dev:http &
        MCP_PID=$!
        cd ..

        # Start Dashboard Server
        cd dashboard-server
        export PATH="$HOME/.bun/bin:$PATH"
        timeout 30s bun run start &
        DASHBOARD_PID=$!
        cd ..

        # Start Dashboard UI preview
        cd dashboard-ui
        timeout 30s npm run preview &
        UI_PID=$!
        cd ..

        # Wait for services to start
        sleep 10

        # Test services
        echo "Testing MCP Server health..."
        curl -f http://localhost:3000/health || echo "MCP Server test failed"

        echo "Testing Dashboard Server health..."
        curl -f http://localhost:3001/health || echo "Dashboard Server test failed"

        echo "Testing Dashboard UI..."
        curl -f http://localhost:4173/ || echo "Dashboard UI test failed"

        # Cleanup
        kill $MCP_PID $DASHBOARD_PID $UI_PID 2>/dev/null || true
        echo "✅ Local integration test completed"

    - name: Integration test - AWS (GitHub Actions)
      if: ${{ !contains(github.actor, 'nektos/act') }}
      run: |
        echo "Running integration tests against deployed AWS infrastructure..."

        # Test against real deployed services
        DASHBOARD_URL="${{ needs.deploy-infrastructure.outputs.dashboard-url }}"

        if [ ! -z "$DASHBOARD_URL" ]; then
          echo "Testing Dashboard at: $DASHBOARD_URL"
          curl -f "$DASHBOARD_URL/health" || echo "Dashboard health check failed"
          curl -f "$DASHBOARD_URL/" || echo "Dashboard UI test failed"
        fi

        # Test MCP Server via Dashboard Server proxy
        curl -f "$DASHBOARD_URL/api/mcp/health" || echo "MCP Server proxy test failed"

        echo "✅ AWS integration test completed"
      env:
        NODE_ENV: test
        ENABLE_DEV_AUTH: true

  cleanup-infrastructure:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, integration-test]
    # Only run on GitHub Actions (not act) and always run (even if tests fail)
    if: ${{ !contains(github.actor, 'nektos/act') && always() }}
    steps:
    - uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.5

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Destroy test infrastructure
      run: |
        WORKSPACE_ID="${{ needs.deploy-infrastructure.outputs.workspace-id }}"

        cd infra/workspaces/small
        terraform init
        terraform workspace select $WORKSPACE_ID
        terraform destroy -auto-approve -var="env=ci-test"
        terraform workspace select default
        terraform workspace delete $WORKSPACE_ID

        echo "✅ Infrastructure cleaned up: $WORKSPACE_ID"

  security-full:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Comprehensive security scan
      run: |
        echo "Running comprehensive security scan..."

        # Check for sensitive data across entire project
        if find . -type f \( -name "*.js" -o -name "*.ts" -o -name "*.json" -o -name "*.md" \) \
          -not -path "./.git/*" \
          -not -path "./node_modules/*" \
          -not -path "./.terraform/*" \
          -not -path "./.claude/*" \
          -exec grep -l "baursoftware\|545027c4\|09c21e37" {} + 2>/dev/null; then
          echo "❌ Found hardcoded sensitive data"
          exit 1
        fi

        # Check for AWS credentials
        if find . -type f \( -name "*.js" -o -name "*.ts" -o -name "*.json" \) \
          -not -path "./node_modules/*" \
          -exec grep -l -E "aws_access_key_id.*=.*[A-Z0-9]{20}|aws_secret_access_key.*=.*[A-Za-z0-9/+=]{40}" {} + 2>/dev/null; then
          echo "❌ Found potential AWS credentials"
          exit 1
        fi

        # Check for hardcoded localhost in production code
        if find . -name "*.ts" -o -name "*.js" \
          -not -path "./node_modules/*" \
          -not -path "./**/*.test.*" \
          -not -path "./**/*.spec.*" \
          -not -path "./.github/*" \
          -exec grep -l "localhost:[0-9]" {} + 2>/dev/null; then
          echo "⚠️  Warning: Found hardcoded localhost URLs"
        fi

        echo "✅ Security scan completed"